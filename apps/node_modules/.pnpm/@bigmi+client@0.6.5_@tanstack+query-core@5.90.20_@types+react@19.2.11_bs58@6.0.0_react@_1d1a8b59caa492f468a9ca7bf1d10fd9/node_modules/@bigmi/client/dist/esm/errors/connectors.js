import { BaseError, } from '@bigmi/core';
export class ProviderNotFoundError extends BaseError {
    constructor() {
        super('Provider not found.');
        this.name = 'ProviderNotFoundError';
        this.message = 'Provider not found';
        this.code = 243;
    }
}
export class ChainNotSupportedError extends BaseError {
    constructor(chainId, connector) {
        super(`Chain ${chainId.toString()} is not supported by ${connector} `);
        this.name = 'ChainNotSupportedError';
    }
}
export class ConnectorChainIdDetectionError extends BaseError {
    constructor({ connector }) {
        super(`Chain ID detection failed for connector "${connector}".`, {
            metaMessages: [
                'The connector needs at least one account to analyze the address format and determine the Bitcoin network.',
                'Please ensure the wallet is connected and has accounts available.',
                'Try reconnecting the wallet or checking if the wallet extension is properly installed.',
            ],
        });
        this.name = 'ConnectorChainIdDetectionError';
    }
}
export class ConnectorAlreadyConnectedError extends BaseError {
    constructor() {
        super('Connector already connected.');
        this.name = 'ConnectorAlreadyConnectedError';
    }
}
export class ConnectorNotConnectedError extends BaseError {
    constructor() {
        super('Connector not connected.');
        this.name = 'ConnectorNotConnectedError';
    }
}
export class ConnectorNotFoundError extends BaseError {
    constructor() {
        super('Connector not found.');
        this.name = 'ConnectorNotFoundError';
    }
}
export class ConnectorAccountNotFoundError extends BaseError {
    constructor({ address, connector, }) {
        super(`Account "${address}" not found for connector "${connector}".`);
        this.name = 'ConnectorAccountNotFoundError';
    }
}
export class ConnectorChainMismatchError extends BaseError {
    constructor({ connectionChainId, connectorChainId, }) {
        super(`The current chain of the connector (id: ${connectorChainId}) does not match the connection's chain (id: ${connectionChainId}).`, {
            metaMessages: [
                `Current Chain ID:  ${connectorChainId}`,
                `Expected Chain ID: ${connectionChainId}`,
            ],
        });
        this.name = 'ConnectorChainMismatchError';
    }
}
export class ConnectorNetworkMismatchError extends BaseError {
    constructor({ connectionNetwork, connectorNetwork, }) {
        super(`The current network of the connector (${connectorNetwork}) does not match the connection's network (${connectionNetwork}).`, {
            metaMessages: [
                `Current Network:  ${connectorNetwork}`,
                `Expected Network: ${connectionNetwork}`,
            ],
        });
        this.name = 'ConnectorNetworkMismatchError';
    }
}
export class ConnectorUnavailableReconnectingError extends BaseError {
    constructor({ connector }) {
        super(`Connector "${connector.name}" unavailable while reconnecting.`, {
            details: [
                'During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.',
                'All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.',
                'This error commonly occurs for connectors that asynchronously inject after reconnection has already started.',
            ].join(' '),
        });
        this.name = 'ConnectorUnavailableReconnectingError';
    }
}
//# sourceMappingURL=connectors.js.map